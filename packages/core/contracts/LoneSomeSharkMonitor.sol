// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import { KeeperRegistryBaseInterface } from "./interfaces/KeeperRegistryInterface.sol";
import { KeeperCompatibleInterface } from "@chainlink/contracts/src/v0.6/interfaces/KeeperCompatibleInterface.sol";
import { Subscribers } from "./Subscribers.sol";
import { PaybackLoan } from "./PaybackLoan.sol";
contract LoneSomeSharkMonitor is KeeperCompatibleInterface {

    Subscribers immutable subscribers;
    KeeperRegistryBaseInterface immutable registry;
    bool internal pause;
    bool internal test_trigger;
    address internal admin;
    uint96 internal linkCost = 5*10**17;
    address immutable link;
    uint internal registryID;
    
    constructor(Subscribers _subscribers, KeeperRegistryBaseInterface _registry, address _link) public {
        subscribers = _subscribers;
        admin = msg.sender;
        registry = _registry;
        link = _link;
    }

    event SuccessFlashEvent(address subscriber, address[] assets, uint[] amounts);
    event CatchFlashEvent(address subscriber, address[] assets, uint[] amounts);
    event MonitoringTriggered(bool _paused, bool _test_triggered);
    function updateRegistryId(uint _id)public{
        require(admin == msg.sender, "require admin to update link cost");
        registryID = _id;
    }
    function updateLinkCost(uint96 _new_cost) public {
        require(admin == msg.sender, "require admin to update link cost");
        linkCost = _new_cost;
    }

    function setPause(bool _pause) public {
        require(msg.sender == admin, "need to be admin");
        pause = _pause;
    }

    function setTrigger(bool _trigger) public {
        test_trigger = _trigger;
    }
    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
        if(test_trigger){
            upkeepNeeded = test_trigger;
        } else if(pause){
            upkeepNeeded = !pause;
        } else {
            upkeepNeeded = subscribers.monitorSubscribersHealth();
        }
        if(upkeepNeeded){
            emit MonitoringTriggered(pause, test_trigger);
        }
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
        address[] memory unhealthy_accounts = subscribers.getUnhealthySubscribers();
        for( uint i = 0; i < unhealthy_accounts.length; i++) {
            if(unhealthy_accounts[i] != address(0)) {
                (address[] memory _assets, uint[] memory _amounts) = subscribers.getAssetsAndAmounts(unhealthy_accounts[i]);
                if(_assets.length == _amounts.length) {
                    address _payback = subscribers.getAccount(unhealthy_accounts[i]).payback;
                    try PaybackLoan(_payback).flashLoanCall(unhealthy_accounts[i], _assets, _amounts) {
                        emit SuccessFlashEvent(unhealthy_accounts[i], _assets, _amounts);
                    } catch {
                        emit CatchFlashEvent(unhealthy_accounts[i], _assets, _amounts);
                    }
                }
            }
        }
    } 

    // need to add this 
    function addFunds() public payable {
        // subscribers.addedFunds();
        registry.addFunds(registryID, linkCost);
    }

    receive() external payable {
        // console.log("calling out receive with value: %s", msg.value);
        // console.log("calling out receive with msg.sender: %s", msg.sender);
    }  
}